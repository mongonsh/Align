"""
ExportConcept: Package mockup for sharing
Purpose: Approve mockup -> Download shareable file
"""

from pathlib import Path
from datetime import datetime
from typing import Optional
import zipfile
import io


class ExportConcept:
    """
    Handles exporting mockups in various formats.
    Free-standing concept focused on file packaging.
    """

    def __init__(self):
        self.export_format = "html"
        self.exports = {}

    def export(self, mockup_html: str, mockup_id: str, metadata: Optional[dict] = None) -> bytes:
        """
        Generate downloadable HTML file.

        Args:
            mockup_html: HTML content to export
            mockup_id: ID of the mockup
            metadata: Optional metadata to include

        Returns:
            HTML file as bytes
        """
        # Add metadata as HTML comments
        html_with_metadata = self._add_metadata_comments(mockup_html, mockup_id, metadata)

        return html_with_metadata.encode('utf-8')

    def export_with_assets(
        self,
        mockup_html: str,
        mockup_id: str,
        assets: Optional[dict] = None
    ) -> bytes:
        """
        Export mockup as ZIP with assets.

        Args:
            mockup_html: HTML content
            mockup_id: ID of the mockup
            assets: Dict of filename -> content for additional files

        Returns:
            ZIP file as bytes
        """
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # Add main HTML file
            zip_file.writestr('index.html', mockup_html)

            # Add assets if provided
            if assets:
                for filename, content in assets.items():
                    zip_file.writestr(filename, content)

            # Add README
            readme = self._generate_readme(mockup_id)
            zip_file.writestr('README.md', readme)

        return zip_buffer.getvalue()

    def prepare_response(self, mockup_html: str, mockup_id: str) -> dict:
        """
        Prepare API response with mockup data.

        Args:
            mockup_html: HTML content
            mockup_id: ID of the mockup

        Returns:
            Response dict with HTML and metadata
        """
        return {
            "mockup_id": mockup_id,
            "html": mockup_html,
            "download_url": f"/api/export/{mockup_id}",
            "preview_url": f"/api/mockup/{mockup_id}/preview",
            "exported_at": datetime.now().isoformat(),
        }

    def _add_metadata_comments(
        self,
        html: str,
        mockup_id: str,
        metadata: Optional[dict]
    ) -> str:
        """Add metadata as HTML comments."""
        comment = f"""<!--
Generated by Align - AI-Powered Mockup Generator
Mockup ID: {mockup_id}
Generated At: {datetime.now().isoformat()}
"""
        if metadata:
            comment += f"Prompt: {metadata.get('prompt', 'N/A')}\n"
            comment += f"Requirements: {metadata.get('requirements', {})}\n"

        comment += "-->\n\n"

        # Insert after <!DOCTYPE> or at the beginning
        if "<!DOCTYPE" in html:
            parts = html.split(">", 1)
            return parts[0] + ">\n" + comment + parts[1]
        else:
            return comment + html

    def _generate_readme(self, mockup_id: str) -> str:
        """Generate README for exported package."""
        return f"""# Align Mockup Export

**Mockup ID:** {mockup_id}
**Generated:** {datetime.now().isoformat()}

## Files

- `index.html` - Your generated mockup

## Usage

1. Open `index.html` in any modern web browser
2. The mockup is fully self-contained with inline CSS
3. Share this file with your team for approval

## About Align

Align creates visual mockups from customer descriptions, ensuring
customers and engineers see the exact same picture before coding starts.

Built for the De-Vibed Hackathon
Sponsored by CommandCenter (cc.dev)
"""

    def get_filename(self, mockup_id: str, format: str = "html") -> str:
        """Generate appropriate filename for export."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        if format == "zip":
            return f"align_mockup_{mockup_id[:8]}_{timestamp}.zip"
        else:
            return f"align_mockup_{mockup_id[:8]}_{timestamp}.html"
